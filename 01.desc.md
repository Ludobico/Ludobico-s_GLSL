매우 간단한 코드지만, 상당히 중요한 내용을 엿볼수 있는데

- 쉐이더 언어는 color 값을 리턴하는 main 함수이고, 이는 C와 유사하다.

- 마지막으로 리턴되는 픽셀 색 값은, `gl_FragColor`라는 전역변수에 대입된다.

- 이 C언어 형태의 언어는, 미리 선언된 변수들(gl_FragColor같은), 함수와 타입을 가진다. 이 예제의 경우, 실수로 이루어진 4차원 벡터 타입인 `vec4`, 더 나아가면서 `vec3`나 `vec2`, `float`, `int`또한 `bool`같은 것들이 보이게 될것이다.

- `vec4` 타입을 자세히 살펴보면, 각 인수는 R,G,B그리고 Alpha 채널이다. 이 값들은 노멀라이즈된 값이 0.0 에서 1.0으로 맵핑된것이다. 나중에 나아가면서 노멀라이징을 어떻게 하는지, map을 어떻게 하는지 살펴보게 될것이다.

- 실수 타입들은 쉐이더에서 신경써야할 부분중 하나인데, precision(실수정확도)의 정도가 퍼포먼스에 영향을 미치기 때문이다. 낮은 정도의 precision을 가질수록 빠른 렌더 속도를 가지지만, 렌더 퀄리티가 그만큼 떨어진다는 것을 의미한다. 첫번째 라인을 보면(precision mediump float;) 라는 내용이 보이는데, `실수정화도를 중간` 정도로 맞춘것이다.
  높게는 precision highp float; 낮게는 pricision lowp float;이다.

- 마지막으로, GLSL에서는 데이터 타입의 casting이 확보되지 않는다. 무슨말인가하면, 제초업체들은 그래픽카드의 연산을 가속화 하기위해 각각 다른 시도들을 하였는데, 결국은 이것은 최소사양을 저격하고 있다. 우리의 `vec4`또한, float라는 데이터타입을 예상하게 되는것이다. 앞으로 쉐이더 프로그램을 하면서 실수의 경우에는 항상 `점을 포함`하여 이변수의 ,값이 실수임을 명시하자, 예를 들어 아래와 같은 코드는 작동이 안될것이다.

```c
void main(){
    gl_FragColor = vec4(1,0,0,1); //ERROR
}
```
